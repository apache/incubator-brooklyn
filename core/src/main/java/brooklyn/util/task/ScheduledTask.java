/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package brooklyn.util.task;

import static brooklyn.util.GroovyJavaMethods.elvis;
import static brooklyn.util.GroovyJavaMethods.truth;

import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

import brooklyn.management.Task;
import brooklyn.util.collections.MutableMap;
import brooklyn.util.time.Duration;

import com.google.common.base.Throwables;

public class ScheduledTask extends BasicTask {

    // TODO It looks like now groovy callers construct ScheduledTask with these values in the map constructor.
    // How does that work in pure-java!?
    // Adding builder-like-setters so can be used in Java. But would be much nicer if this was immutable.
    // Previous (out-of-date?) todo was:
    //     See BasicExecutionManager.submitNewScheduledTask for where these fields are actually set.
    //     Would be nice if the scheduledTask was more self-contained, rather than its fields being
    //     modified by a different class in a non-obvious way...
    
	final Callable<Task<?>> taskFactory;
	/** initial delay before running, set as flag in constructor; defaults to 0 */
	protected Duration delay;
	/** time to wait between executions, or null if not to repeat (default), set as flag to constructor;
	 * this may be modified for subsequent submissions by a running task generated by the factory 
	 * using getSubmittedByTask().setPeriod(Duration) */
	protected Duration period = null;
	/** optional, set as flag in constructor; defaults to null meaning no limit */
	protected Integer maxIterations = null;
	
	protected int runCount=0;
	protected Task recentRun, nextRun;

	public int getRunCount() { return runCount; }
	public ScheduledFuture getNextScheduled() { return (ScheduledFuture)result; }

    public ScheduledTask(Callable<Task<?>> taskFactory) {
        this(MutableMap.of(), taskFactory);
    }

    public ScheduledTask(final Task<?> task) {
        this(MutableMap.of(), task);
    }

    public ScheduledTask(Map flags, final Task<?> task){
        this(flags, new Callable<Task<?>>(){
            @Override
            public Task<?> call() throws Exception {
                return task;
            }});
    }

	public ScheduledTask(Map flags, Callable<Task<?>> taskFactory) {
		super(flags);
		this.taskFactory = taskFactory;
		
		delay = Duration.of(elvis(flags.remove("delay"), 0));
		period = Duration.of(elvis(flags.remove("period"), null));
		maxIterations = elvis(flags.remove("maxIterations"), null);
	}
	
	public ScheduledTask delay(Duration d) {
	    this.delay = d;
	    return this;
	}
	public ScheduledTask delay(long val) {
	    return delay(Duration.millis(val));
	}

    public ScheduledTask period(Duration d) {
        this.period = d;
        return this;
    }
    public ScheduledTask period(long val) {
        return period(Duration.millis(val));
    }

    public ScheduledTask maxIterations(int val) {
        this.maxIterations = val;
        return this;
    }

    public Callable<Task<?>> getTaskFactory() {
        return taskFactory;
    }

	public Task newTask() {
	    try {
	        return taskFactory.call();
	    } catch (Exception e) {
	        throw Throwables.propagate(e);
	    }
    }
	
	protected String getActiveTaskStatusString(int verbosity) {
		StringBuilder rv = new StringBuilder("Scheduler");
		if (runCount>0) rv.append(", iteration "+(runCount+1));
		if (recentRun!=null) rv.append(", last run "+(System.currentTimeMillis()-recentRun.getStartTimeUtc())+" ms ago");
		if (truth(getNextScheduled())) {
			long untilNext = getNextScheduled().getDelay(TimeUnit.MILLISECONDS);
			if (untilNext>0)
			    rv.append(", next in "+untilNext+" ms");
			else 
			    rv.append(", next imminent");
		}
		return rv.toString();
	}
	
	@Override
	public boolean isDone() {
		return isCancelled() || (maxIterations!=null && maxIterations <= runCount) || (period==null && nextRun!=null && nextRun.isDone());
	}
	
	public synchronized void blockUntilFirstScheduleStarted() {
	    // TODO Assumes that maxIterations is not negative!
        while (true) {
            if (isCancelled()) throw new CancellationException();
            if (recentRun==null)
                try {
                    wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    Throwables.propagate(e);
                }
            if (recentRun!=null) return;
        }
	}
	
	public void blockUntilEnded() {
		while (!isDone()) super.blockUntilEnded();
	}

	/** gets the value of the most recently run task */
	public Object get() throws InterruptedException, ExecutionException {
		blockUntilStarted();
        blockUntilFirstScheduleStarted();
		return (truth(recentRun)) ? recentRun.get() : result.get();
	}
}
